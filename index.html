<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="ðŸŽ§ Nekohacker591 Portfolio">
  <meta property="og:description" content="Check out my music portfolio!">
  <meta property="og:type" content="website">
  <title>ðŸŽ§ Nekohacker591 Portfolio</title>
  <style>
    /* --- Global Styles & CSS Variables --- */
    :root {
      --primary-color: #ff4d4d; /* Your signature red */
      --primary-color-hover: #ff6666; /* Lighter red for hover */
      --background-color: #121212; /* A deep, modern dark grey */
      --surface-color: #1e1e1e;   /* For player cards and input backgrounds */
      --surface-highlight: #2a2a2a; /* Slightly lighter for borders, progress track */
      --text-color: #e0e0e0;       /* Primary text - light grey */
      --text-secondary-color: #b3b3b3; /* Secondary text - medium grey */
      --border-radius: 8px;          /* Consistent rounded corners */
      --transition-speed: 0.2s ease-in-out;
    }

    body {
      font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.6;
    }

    h1 {
      color: var(--primary-color);
      text-align: center;
      margin-bottom: 30px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    /* --- Search Bar & Header Controls --- */
    .search-bar {
      margin-bottom: 20px;
      width: 100%;
      max-width: 650px;
    }

    .search-input {
      width: 100%;
      padding: 12px 15px;
      font-size: 16px;
      border: 1px solid var(--surface-highlight);
      border-radius: var(--border-radius);
      background-color: var(--surface-color);
      color: var(--text-color);
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
    }
    .search-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(255, 77, 77, 0.3); /* Softer focus ring */
    }
    .search-input::placeholder {
      color: var(--text-secondary-color);
    }

    .controls-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      width: 100%;
      max-width: 650px;
      margin-bottom: 15px;
      color: var(--text-secondary-color);
    }
    .controls-header label {
      margin-right: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    .controls-header input[type="checkbox"] {
      accent-color: var(--primary-color); /* Modern way to color checkboxes */
      cursor: pointer;
      transform: scale(1.1);
      margin-right: 5px; /* Spacing for the label */
    }

    /* --- Player Container & Individual Players --- */
    .scroll-container {
      display: flex;
      flex-direction: column;
      gap: 25px;
      width: 100%;
      max-width: 650px;
    }

    .player {
      background-color: var(--surface-color);
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      border: 1px solid var(--surface-color); /* Start with matching border */
      transition: transform var(--transition-speed), box-shadow var(--transition-speed), border-color var(--transition-speed);
    }
    .player:hover {
        transform: translateY(-4px);
        box-shadow: 0 7px 18px rgba(0,0,0,0.3);
    }
    .player.player-playing {
      border-color: var(--primary-color);
      box-shadow: 0 0 12px rgba(255, 77, 77, 0.3), 0 4px 12px rgba(0,0,0,0.25);
    }

    .track-title {
      font-size: 20px;
      margin-bottom: 15px;
      color: var(--text-color);
      font-weight: 500;
    }

    /* --- Player Controls (Play button, Progress bar area) --- */
    .controls {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 15px;
    }

    .play-btn {
      background-color: var(--primary-color);
      border: none;
      color: #fff;
      font-size: 20px; /* For the icon like â–¶ or â–®â–® */
      width: 48px;
      height: 48px;
      border-radius: 50%; /* Circular button */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0; /* Prevent shrinking */
      transition: background-color var(--transition-speed), transform var(--transition-speed);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .play-btn:hover {
      background-color: var(--primary-color-hover);
      transform: scale(1.05);
    }
    .play-btn:active {
      transform: scale(0.98);
    }

    /* --- Progress Bar --- */
    .progress-container {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .progress {
      flex-grow: 1;
      height: 8px;
      background-color: var(--surface-highlight);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
    }

    .progress-filled {
      height: 100%;
      background-color: var(--primary-color);
      width: 0;
      border-radius: 4px;
      transition: width 0.1s linear; /* Keep this for smoothness, others can be var(--transition-speed) */
    }

    .current-time, .duration {
      font-size: 13px;
      color: var(--text-secondary-color);
      min-width: 38px; /* Prevent layout shifts */
      text-align: center;
      flex-shrink: 0;
    }

    /* --- Action Buttons (Download, Share) --- */
    .actions {
      margin-top: 15px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap; /* Allow wrapping on small screens if needed */
    }

    .download-link, .share-btn {
      background-color: var(--surface-highlight);
      color: var(--text-secondary-color);
      padding: 8px 15px;
      border-radius: var(--border-radius);
      text-decoration: none;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background-color var(--transition-speed), color var(--transition-speed), transform var(--transition-speed);
      display: inline-flex;
      align-items: center;
      gap: 6px; /* Space between icon and text */
    }
    .download-link:hover, .share-btn:hover {
      background-color: var(--primary-color);
      color: #fff;
      transform: translateY(-1px);
    }

    .copied {
      opacity: 0;
      color: var(--primary-color);
      font-size: 13px;
      transition: opacity 0.3s var(--transition-speed);
      margin-left: 5px;
    }
    .copied.show {
      opacity: 1;
    }

    /* --- Volume Controls --- */
    .volume-container {
      display: flex;
      align-items: center;
      gap: 12px; /* Increased gap */
      margin-top: 15px;
    }

    .mute-btn {
      background-color: transparent;
      border: 1px solid var(--text-secondary-color);
      color: var(--text-secondary-color);
      font-size: 18px; /* For ðŸ”‡ / ðŸ”Š icons */
      width: 38px; /* Slightly larger */
      height: 38px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: background-color var(--transition-speed), color var(--transition-speed), border-color var(--transition-speed);
    }
    .mute-btn:hover {
      border-color: var(--primary-color);
      color: var(--primary-color);
    }

    .volume-slider {
      flex-grow: 1;
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: var(--surface-highlight);
      outline: none;
      border-radius: 3px;
      cursor: pointer;
      transition: opacity var(--transition-speed);
    }
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: 3px solid var(--surface-color); /* Make it pop from the track */
      transition: background-color var(--transition-speed);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: 3px solid var(--surface-color);
      transition: background-color var(--transition-speed);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .volume-slider:hover::-webkit-slider-thumb { background: var(--primary-color-hover); }
    .volume-slider:hover::-moz-range-thumb { background: var(--primary-color-hover); }

    .volume-slider:disabled { opacity: 0.6; cursor: default; }
    .volume-slider:disabled::-webkit-slider-thumb { background: var(--text-secondary-color); border-color: var(--surface-color); }
    .volume-slider:disabled::-moz-range-thumb { background: var(--text-secondary-color); border-color: var(--surface-color); }

    /* --- Responsive Adjustments --- */
    @media (max-width: 680px) { /* Adjusted breakpoint */
      body {
        padding: 15px;
      }
      h1 {
        font-size: 1.8em; /* Relative sizing */
        margin-bottom: 25px;
      }
      .player {
        padding: 15px;
      }
      .track-title {
        font-size: 18px;
      }
      .controls {
        gap: 10px;
        margin-bottom: 12px;
      }
      .play-btn {
        width: 44px;
        height: 44px;
        font-size: 18px;
      }
      .current-time, .duration {
          font-size: 12px;
          min-width: 32px;
      }
      .actions, .volume-container {
        margin-top: 12px;
      }
      .download-link, .share-btn {
        padding: 7px 12px;
        font-size: 12px;
      }
      .mute-btn {
        width: 34px;
        height: 34px;
        font-size: 16px;
      }
      .volume-slider::-webkit-slider-thumb { width: 14px; height: 14px; border-width: 2px; }
      .volume-slider::-moz-range-thumb { width: 14px; height: 14px; border-width: 2px; }
    }

    /* Styling for when a track is shared directly */
    body.share-mode .scroll-container {
        max-width: 700px; /* Allow shared player to be a bit wider if desired */
    }
    body.share-mode h1,
    body.share-mode .search-bar,
    body.share-mode .controls-header {
        display: none;
    }
    body.share-mode .player {
        margin-top: 20px; /* Add some top margin when it's the only thing */
    }

  </style>
</head>
<body>
  <h1>ðŸŽ§ Nekohacker591 Portfolio</h1>

  <div class="search-bar">
    <input type="text" class="search-input" placeholder="Search for a track...">
  </div>

  <div class="controls-header">
    <input type="checkbox" id="autoplay-next"> <!-- Initial state set by JS -->
    <label for="autoplay-next">Autoplay Next</label>
  </div>

  <div class="scroll-container" id="player-container">
    <!-- Players will be injected here -->
  </div>

  <script>
    const globalPlayerState = {
        currentPlayingAudio: null,
        currentPlayingPlayerDiv: null,
        lastVolume: parseFloat(localStorage.getItem('nekohacker_globalVolume')) || 0.75,
        isMuted: JSON.parse(localStorage.getItem('nekohacker_isMuted')) || false,
        get autoplayNext() {
            return document.getElementById('autoplay-next').checked;
        },
        set autoplayNext(value) {
            document.getElementById('autoplay-next').checked = value;
            localStorage.setItem('nekohacker_autoplayNext', JSON.stringify(value));
        }
    };

    const autoplayCheckbox = document.getElementById('autoplay-next');
    const storedAutoplay = localStorage.getItem('nekohacker_autoplayNext');
    if (storedAutoplay !== null) {
        autoplayCheckbox.checked = JSON.parse(storedAutoplay);
    } else {
        autoplayCheckbox.checked = true; // Default to true if not in localStorage
        globalPlayerState.autoplayNext = true; // Sync global state
    }

    autoplayCheckbox.addEventListener('change', (e) => {
        globalPlayerState.autoplayNext = e.target.checked;
    });


    function formatTime(seconds) {
      if (isNaN(seconds) || seconds === Infinity) return '--:--';
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }

    const tracks = [
      { title: "Rock and Roll", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/rock%20and%20roll%20mixed.wav?download=true" },
      { title: "Chill Synth Wave", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/chill%20song%20mixed.wav?download=true" },
      { title: "The Video Game Melody 2025 Edition", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/video%20game%20melody.wav?download=true" },
      { title: "Elyisan", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/idol%20song%202.wav?download=true" },
      { title: "Bang Dream", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/bang%20dream.wav?download=true" },
      { title: "Red Zone Remix", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/red%20zone%20serum%202%20evaluation%20super%20massive.wav?download=true" },
      { title: "Nee Nee Nee", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/nee%20nee%20nee%20final%20ozone%20edition.wav?download=true" },
      { title: "Circulation", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/circulation.wav?download=true" },
      { title: "Flowering Night Remix", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/flowering%20night.wav?download=true" },
      { title: "The Video Game Melody 2024 Edition ", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/mario%20melody.wav?download=true" },
      { title: "8 Bit Magic", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/8%20bit%20magic.wav?download=true" },
      { title: "Akuno Meshitsukai", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/akuno_meshitsukai%20premaster.wav?download=true" },
      { title: "Luminous Neko", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/anime%20op%202%20like%20song%20group%20master.wav?download=true" },
      { title: "Nekos's Bon AppÃ©titâ™¡", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/anime%20op%20after%20mastering.wav?download=true" },
      { title: "Do-Dai Neko Joy", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/do-dai%20neko%20joy%20remix%20trail%20test.wav?download=true" },
      { title: "Neko No Yorokobi", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/Neko%20no%20yorokobi.wav?download=true" },
      { title: "Save The World", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/good%20remix%20rock%20sprit%20rock.wav?download=true" }
    ];

    const playerContainer = document.getElementById("player-container");
    const searchInput = document.querySelector('.search-input'); // Defined earlier for keydown check

    function initializeAudioForPlayer(playerDiv) {
      if (playerDiv.audioInitialized) return;

      const audio = new Audio();
      audio.preload = "metadata";
      playerDiv.audio = audio;
      playerDiv.audioInitialized = true;

      const playBtn = playerDiv.querySelector('.play-btn');
      const progressFilled = playerDiv.querySelector('.progress-filled');
      const progressBar = playerDiv.querySelector('.progress');
      const volumeSlider = playerDiv.querySelector('.volume-slider');
      const muteBtn = playerDiv.querySelector('.mute-btn');
      const currentTimeDisplay = playerDiv.querySelector('.current-time');
      const durationDisplay = playerDiv.querySelector('.duration');
      const trackTitleElement = playerDiv.querySelector('.track-title');

      // Initial state based on global/persisted settings
      audio.muted = globalPlayerState.isMuted;
      audio.volume = globalPlayerState.isMuted ? 0 : globalPlayerState.lastVolume; // This seems redundant if audio.muted works right
      volumeSlider.value = globalPlayerState.lastVolume; // Slider always reflects unmuted volume preference
      muteBtn.textContent = globalPlayerState.isMuted ? 'ðŸ”Š' : 'ðŸ”‡';
      volumeSlider.disabled = globalPlayerState.isMuted;


      audio.addEventListener('loadedmetadata', () => {
        durationDisplay.textContent = formatTime(audio.duration);
        if (playerDiv.shouldAutoPlay) {
            playBtn.click();
            playerDiv.shouldAutoPlay = false;
        }
      });

      audio.addEventListener('timeupdate', () => {
        if (audio.duration) {
          const percent = (audio.currentTime / audio.duration) * 100;
          progressFilled.style.width = percent + '%';
        }
        currentTimeDisplay.textContent = formatTime(audio.currentTime);
        if (!audio.paused) {
          document.title = `ðŸŽ§ ${trackTitleElement.textContent} - Nekohacker591`;
        }
      });

      audio.addEventListener('ended', () => {
        playBtn.textContent = 'â–¶';
        progressFilled.style.width = '0%';
        currentTimeDisplay.textContent = formatTime(0);
        playerDiv.classList.remove('player-playing');
        if (globalPlayerState.currentPlayingPlayerDiv === playerDiv) {
            globalPlayerState.currentPlayingAudio = null;
            globalPlayerState.currentPlayingPlayerDiv = null;
            document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
        }

        if (globalPlayerState.autoplayNext) {
            let allPlayers = Array.from(playerContainer.children).filter(p => p.style.display !== 'none');
            let currentPlayerIndex = allPlayers.indexOf(playerDiv);

            if (currentPlayerIndex !== -1 && currentPlayerIndex < allPlayers.length - 1) {
                const nextPlayerDiv = allPlayers[currentPlayerIndex + 1];
                if (nextPlayerDiv) {
                    const nextPlayBtn = nextPlayerDiv.querySelector('.play-btn');
                    if (nextPlayBtn) {
                        if (!nextPlayerDiv.audioInitialized) {
                           initializeAudioForPlayer(nextPlayerDiv);
                        }
                        if (!nextPlayerDiv.audio.src && nextPlayerDiv.dataset.src) {
                            nextPlayerDiv.audio.src = nextPlayerDiv.dataset.src;
                        }
                        nextPlayBtn.click(); // This should trigger play
                    }
                }
            }
        }
      });
      
      audio.addEventListener('volumechange', () => {
          // Update UI based on audio's current state (volume and muted)
          muteBtn.textContent = audio.muted || audio.volume === 0 ? 'ðŸ”Š' : 'ðŸ”‡';
          volumeSlider.disabled = audio.muted;
          
          // If not muted by the API, slider reflects actual volume
          // If muted by API, slider still shows 'lastVolume' but is disabled
          if (!audio.muted) {
            volumeSlider.value = audio.volume;
            globalPlayerState.lastVolume = audio.volume; // Store unmuted volume
          }
          
          globalPlayerState.isMuted = audio.muted; // Update global mute state

          localStorage.setItem('nekohacker_globalVolume', globalPlayerState.lastVolume);
          localStorage.setItem('nekohacker_isMuted', JSON.stringify(globalPlayerState.isMuted));
      });


      volumeSlider.addEventListener('input', () => {
        const newVolume = parseFloat(volumeSlider.value);
        audio.muted = false; // Explicitly unmute if user interacts with slider
        audio.volume = newVolume;
        // 'volumechange' event handles further UI updates and localStorage
      });

      muteBtn.addEventListener('click', () => {
          audio.muted = !audio.muted;
          // 'volumechange' event will handle UI and localStorage updates
      });

      playBtn.addEventListener('click', () => {
        if (!audio.src && playerDiv.dataset.src) { // Ensure src is set if not already
            audio.src = playerDiv.dataset.src;
        }

        if (audio.paused) {
          // Pause any other playing audio
          if (globalPlayerState.currentPlayingAudio && globalPlayerState.currentPlayingAudio !== audio) {
            globalPlayerState.currentPlayingAudio.pause();
            if(globalPlayerState.currentPlayingPlayerDiv) {
                globalPlayerState.currentPlayingPlayerDiv.querySelector('.play-btn').textContent = 'â–¶';
                globalPlayerState.currentPlayingPlayerDiv.classList.remove('player-playing');
            }
          }
          // Play this audio
          audio.play().then(() => {
            playBtn.textContent = 'â–®â–®';
            playerDiv.classList.add('player-playing');
            globalPlayerState.currentPlayingAudio = audio;
            globalPlayerState.currentPlayingPlayerDiv = playerDiv;
          }).catch(error => {
            console.error("Damn, audio play failed:", error);
            playBtn.textContent = 'â–¶'; // Reset button if play fails
          });
        } else {
          audio.pause();
          playBtn.textContent = 'â–¶';
          playerDiv.classList.remove('player-playing');
          if (globalPlayerState.currentPlayingAudio === audio) { // Clear global state if this was the one playing
              globalPlayerState.currentPlayingAudio = null;
              globalPlayerState.currentPlayingPlayerDiv = null;
          }
          document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
        }
      });

      progressBar.addEventListener('click', (e) => {
          if (!audio.duration || audio.duration === Infinity) return; 
          const progressBarRect = progressBar.getBoundingClientRect();
          const clickPosition = (e.clientX - progressBarRect.left) / progressBarRect.width;
          audio.currentTime = clickPosition * audio.duration;
          // If paused, manually update UI as 'timeupdate' won't fire immediately
          if (audio.paused) { 
            progressFilled.style.width = (clickPosition * 100) + '%';
            currentTimeDisplay.textContent = formatTime(audio.currentTime);
          }
      });

      // If src needs to be set (it might be deferred until intersection)
      if (!audio.src && playerDiv.dataset.src) {
          audio.src = playerDiv.dataset.src;
      }
    }

    const observerOptions = {
      root: null, // viewport
      rootMargin: '0px',
      threshold: 0.01 // Trigger when even a tiny bit is visible
    };

    const playerObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const playerDiv = entry.target;
          if (!playerDiv.audioInitialized) { 
            initializeAudioForPlayer(playerDiv);
          }
          // Could unobserve here if initialization is strictly one-time:
          // observer.unobserve(playerDiv); 
        }
      });
    }, observerOptions);

    tracks.forEach((track, index) => {
      const playerDiv = document.createElement("div");
      playerDiv.className = "player";
      playerDiv.id = `player-${index}`;
      playerDiv.dataset.src = track.file; // Store src here for lazy loading
      playerDiv.dataset.index = index; // For share links and identification

      playerDiv.innerHTML = `
        <div class="track-title">${track.title}</div>
        <div class="controls">
          <button class="play-btn">â–¶</button>
          <div class="progress-container">
            <span class="current-time">0:00</span>
            <div class="progress"><div class="progress-filled"></div></div>
            <span class="duration">--:--</span>
          </div>
        </div>
        <div class="actions">
          <a class="download-link" href="${track.file}" download="${track.title.replace(/[^\w\s.-]/g, '') || 'track'}.wav">â¬‡ Download</a>
          <button class="share-btn">ðŸ”— Share</button>
          <span class="copied">Copied!</span>
        </div>
        <div class="volume-container">
          <button class="mute-btn">ðŸ”‡</button> <!-- Initial icon state can be set by JS -->
          <input type="range" class="volume-slider" min="0" max="1" step="0.01" value="${globalPlayerState.lastVolume}">
        </div>
      `;
      playerContainer.appendChild(playerDiv);

      const shareBtn = playerDiv.querySelector('.share-btn');
      const copiedMsg = playerDiv.querySelector('.copied');
      const baseUrl = window.location.origin + window.location.pathname;

      shareBtn.addEventListener('click', () => {
        const shareUrl = `${baseUrl}?id=${index}&share=true`;
        navigator.clipboard.writeText(shareUrl).then(() => {
          copiedMsg.classList.add('show');
          setTimeout(() => copiedMsg.classList.remove('show'), 1500);
        }).catch(err => console.error('Failed to copy share link, what a pain: ', err));
      });
      
      playerObserver.observe(playerDiv); // Start observing the player for lazy init
    });


    searchInput.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase();
      document.querySelectorAll('.player').forEach(player => {
        const title = player.querySelector('.track-title').textContent.toLowerCase();
        const isVisible = title.includes(query);
        player.style.display = isVisible ? 'block' : 'none';
        
        // If a playing track is hidden by search, pause it
        if (!isVisible && player.audio && !player.audio.paused) {
            player.audio.pause();
            player.querySelector('.play-btn').textContent = 'â–¶';
            player.classList.remove('player-playing');
            if (globalPlayerState.currentPlayingPlayerDiv === player) {
                globalPlayerState.currentPlayingAudio = null;
                globalPlayerState.currentPlayingPlayerDiv = null;
                document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
            }
        }
      });

      // Update URL with search query
      const newUrl = new URL(window.location.href);
      if (query) {
        newUrl.searchParams.set('s', query.replace(/ /g, '+'));
      } else {
        newUrl.searchParams.delete('s');
      }
      window.history.replaceState({}, '', newUrl);
    });

    function setOgMetaTags(title, description, url) {
      document.title = title; // Also set the document title
      const metaTags = [
        { property: 'og:title', content: title },
        { property: 'og:description', content: description },
        { property: 'og:url', content: url },
        { property: 'og:type', content: 'music.song' }
        // Add og:image if you have an image URL, e.g., { property: 'og:image', content: 'https://example.com/image.jpg' }
      ];
      metaTags.forEach(tag => {
        let meta = document.querySelector(`meta[property="${tag.property}"]`);
        if (!meta) {
          meta = document.createElement('meta');
          meta.setAttribute('property', tag.property);
          document.head.appendChild(meta);
        }
        meta.setAttribute('content', tag.content);
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      const urlParams = new URLSearchParams(window.location.search);
      const id = urlParams.get('id');
      const shareMode = urlParams.get('share') === 'true';
      const searchQuery = urlParams.get('s');

      let pageTitle = 'ðŸŽ§ Nekohacker591 Portfolio';
      let pageDescription = 'Check out my music portfolio!';
      let pageUrl = window.location.origin + window.location.pathname;

      if (shareMode && id !== null && tracks[id]) {
        document.body.classList.add('share-mode'); // Add class for CSS styling
        const track = tracks[id];
        pageTitle = `ðŸŽ§ ${track.title} - Nekohacker591 Portfolio`;
        pageDescription = `Listen to "${track.title}" by Nekohacker591`;
        pageUrl = window.location.href; // Use the full share URL for OG

        const playerToFocus = document.getElementById(`player-${id}`);
        if (playerToFocus) {
          document.querySelectorAll('.player').forEach(p => {
            p.style.display = (p === playerToFocus) ? 'block' : 'none';
          });
          // Hiding of other elements is now primarily handled by CSS via .share-mode
          
          playerContainer.style.maxWidth = 'none'; // Allow full width for shared player
          playerContainer.style.width = '100%';

          if (!playerToFocus.audioInitialized) { // Ensure it's initialized
            initializeAudioForPlayer(playerToFocus);
          }
          playerToFocus.shouldAutoPlay = true; // Flag for autoplay on metadata load
          
          // If src isn't set yet (due to IntersectionObserver not firing yet), set it now.
          if (playerToFocus.audio && !playerToFocus.audio.src && playerToFocus.dataset.src) {
              playerToFocus.audio.src = playerToFocus.dataset.src;
          } 
          // If metadata is already loaded, click play directly (e.g., if it was already visible)
          else if (playerToFocus.audio && playerToFocus.audio.readyState >= HTMLMediaElement.HAVE_METADATA) {
             playerToFocus.querySelector('.play-btn').click(); 
             playerToFocus.shouldAutoPlay = false; // Autoplay handled
          }
          // else, loadedmetadata event will handle the autoplay via playerToFocus.shouldAutoPlay

          playerToFocus.scrollIntoView({ behavior: 'auto', block: 'start' });
        }
      } else if (searchQuery) {
        const cleanQuery = searchQuery.replace(/\+/g, ' ');
        searchInput.value = cleanQuery;
        const event = new Event('input', { bubbles: true, cancelable: true });
        searchInput.dispatchEvent(event); // Trigger search filtering
      }

      setOgMetaTags(pageTitle, pageDescription, pageUrl);
    });

    document.addEventListener('keydown', (e) => {
        // Ignore keydown if focus is on an input field
        if (e.target === searchInput || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        let activeAudio = globalPlayerState.currentPlayingAudio;
        let activePlayerDiv = globalPlayerState.currentPlayingPlayerDiv;

        if (e.code === 'Space') {
            e.preventDefault(); 
            if (activeAudio && activePlayerDiv) {
                activePlayerDiv.querySelector('.play-btn').click();
            } else {
                // Try to play the first visible player
                const firstVisiblePlayer = Array.from(playerContainer.children).find(p => p.style.display !== 'none');
                if (firstVisiblePlayer) {
                    if (!firstVisiblePlayer.audioInitialized) { 
                        initializeAudioForPlayer(firstVisiblePlayer);
                        if (firstVisiblePlayer.audio && !firstVisiblePlayer.audio.src && firstVisiblePlayer.dataset.src) {
                           firstVisiblePlayer.audio.src = firstVisiblePlayer.dataset.src; // Ensure src is set
                        }
                    }
                    // Defer play if audio is not ready
                    if (firstVisiblePlayer.audio && firstVisiblePlayer.audio.readyState < HTMLMediaElement.HAVE_METADATA && firstVisiblePlayer.audio.src) {
                        firstVisiblePlayer.shouldAutoPlay = true; 
                    } else if (firstVisiblePlayer.querySelector('.play-btn')) {
                       firstVisiblePlayer.querySelector('.play-btn').click();
                    }
                }
            }
        } else if (e.code === 'KeyM') { 
            e.preventDefault();
            if (activePlayerDiv && activePlayerDiv.querySelector('.mute-btn')) {
                activePlayerDiv.querySelector('.mute-btn').click();
            } else { // If no active player, try to mute/unmute the first visible one
                const firstVisiblePlayer = Array.from(playerContainer.children).find(p => p.style.display !== 'none');
                if (firstVisiblePlayer && firstVisiblePlayer.audioInitialized && firstVisiblePlayer.audio && firstVisiblePlayer.querySelector('.mute-btn')) {
                     firstVisiblePlayer.querySelector('.mute-btn').click();
                }
            }
        } else if (activeAudio && activePlayerDiv) { // Ensure we have an active player for these
            let handled = false;
            const currentTime = activeAudio.currentTime;
            const duration = activeAudio.duration;
            const volume = activeAudio.volume;

            if (e.code === 'ArrowLeft') {
                if (duration && duration !== Infinity) activeAudio.currentTime = Math.max(0, currentTime - 5); 
                handled = true;
            } else if (e.code === 'ArrowRight') {
                if (duration && duration !== Infinity) activeAudio.currentTime = Math.min(duration, currentTime + 5); 
                handled = true;
            } else if (e.code === 'ArrowUp') {
                activeAudio.muted = false; // Ensure unmuted when adjusting volume
                activeAudio.volume = Math.min(1, volume + 0.05);
                handled = true;
            } else if (e.code === 'ArrowDown') {
                activeAudio.muted = false; // Ensure unmuted
                activeAudio.volume = Math.max(0, volume - 0.05);
                handled = true;
            }
            if (handled) e.preventDefault();
        }
    });
  </script>
</body>
</html>
