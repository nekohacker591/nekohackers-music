<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Default OG Meta Tags -->
  <meta property="og:title" content="ðŸŽ§ Nekohacker591 Portfolio">
  <meta property="og:description" content="Check out my music portfolio!">
  <meta property="og:type" content="website">
  <title>ðŸŽ§ Nekohacker591 Portfolio</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: #fff;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      color: #ff4d4d;
      text-align: center;
      margin-bottom: 20px;
    }
    .search-bar {
      margin-bottom: 20px;
      width: 100%;
      max-width: 600px;
    }
    .search-input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 2px solid #ff4d4d;
      border-radius: 5px;
      background-color: #333;
      color: #fff;
    }
    .controls-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      width: 100%;
      max-width: 600px;
      margin-bottom: 10px;
    }
    .controls-header label {
      margin-right: 5px;
      font-size: 14px;
    }
    .scroll-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 100%;
      max-width: 600px;
    }
    .player {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(255, 77, 77, 0.2); /* Slightly softer shadow */
      border: 1px solid transparent; /* For active state */
      transition: border-color 0.3s ease;
    }
    .player.player-playing { /* Style for the currently playing track */
      border-color: #ff4d4d;
      box-shadow: 0 0 15px rgba(255, 77, 77, 0.7);
    }
    .track-title {
      font-size: 18px;
      margin-bottom: 10px;
      color: #ff4d4d;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .play-btn {
      background-color: #ff4d4d;
      border: none;
      color: #fff;
      font-size: 18px;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      min-width: 40px; /* Ensure button size is consistent */
      text-align: center;
    }
    .progress-container {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .progress {
      flex-grow: 1;
      height: 10px;
      background-color: #444;
      border-radius: 5px;
      overflow: hidden;
      position: relative;
      cursor: pointer; /* Allow seeking by clicking progress bar */
    }
    .progress-filled {
      height: 100%;
      background-color: #ff4d4d;
      width: 0;
      /* transition: width 0.1s linear; Removed for smoother manual seeking */
    }
    .current-time, .duration {
      font-size: 12px;
      color: #ccc;
    }
    .actions {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .download-link, .share-btn {
      background-color: #ff4d4d;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      text-decoration: none;
      border: none;
      cursor: pointer;
      font-size: 12px; /* Consistent font size */
    }
    .copied {
      opacity: 0;
      color: #ff4d4d;
      font-size: 12px;
      transition: opacity 0.3s;
    }
    .copied.show {
      opacity: 1;
    }
    .volume-container { /* Container for volume slider and mute button */
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
    }
    .mute-btn {
      background-color: #555;
      border: none;
      color: #fff;
      font-size: 14px;
      padding: 6px 8px;
      border-radius: 5px;
      cursor: pointer;
    }
    .volume-slider {
      flex-grow: 1; /* Slider takes remaining space */
      /* width: 100%; No, let flexbox handle it */
      margin-top: 0; /* Removed as it's in a flex container now */
    }
  </style>
</head>
<body>
  <h1>ðŸŽ§ Nekohacker591 Portfolio</h1>

  <div class="search-bar">
    <input type="text" class="search-input" placeholder="Search for a track...">
  </div>

  <div class="controls-header">
    <label for="autoplay-next">Autoplay Next:</label>
    <input type="checkbox" id="autoplay-next" checked>
  </div>

  <div class="scroll-container" id="player-container">
    <!-- Players will be injected here -->
  </div>

  <script>
    const globalPlayerState = {
        currentPlayingAudio: null,
        currentPlayingPlayerDiv: null,
        lastVolume: parseFloat(localStorage.getItem('nekohacker_globalVolume')) || 0.75, // Default to 75%
        isMuted: JSON.parse(localStorage.getItem('nekohacker_isMuted')) || false,
        autoplayNext: document.getElementById('autoplay-next').checked
    };

    document.getElementById('autoplay-next').addEventListener('change', function() {
        globalPlayerState.autoplayNext = this.checked;
    });


    function formatTime(seconds) {
      if (isNaN(seconds) || seconds === Infinity) return '--:--';
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }

    const tracks = [
      { title: "Rock and Roll", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/rock%20and%20roll%20mixed.wav?download=true" },
      { title: "Chill Synth Wave", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/chill%20song%20mixed.wav?download=true" },
      { title: "The Video Game Melody 2025 Edition", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/video%20game%20melody.wav?download=true" },
      { title: "Elyisan", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/idol%20song%202.wav?download=true" },
      { title: "Bang Dream", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/bang%20dream.wav?download=true" },
      { title: "Red Zone Remix", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/red%20zone%20serum%202%20evaluation%20super%20massive.wav?download=true" },
      { title: "Nee Nee Nee", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/nee%20nee%20nee%20final%20ozone%20edition.wav?download=true" },
      { title: "Circulation", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/circulation.wav?download=true" },
      { title: "Flowering Night Remix", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/flowering%20night.wav?download=true" },
      { title: "The Video Game Melody 2024 Edition ", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/mario%20melody.wav?download=true" },
      { title: "8 Bit Magic", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/8%20bit%20magic.wav?download=true" },
      { title: "Akuno Meshitsukai", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/akuno_meshitsukai%20premaster.wav?download=true" },
      { title: "Luminous Neko", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/anime%20op%202%20like%20song%20group%20master.wav?download=true" },
      { title: "Nekos's Bon AppÃ©titâ™¡", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/anime%20op%20after%20mastering.wav?download=true" },
      { title: "Do-Dai Neko Joy", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/do-dai%20neko%20joy%20remix%20trail%20test.wav?download=true" },
      { title: "Neko No Yorokobi", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/Neko%20no%20yorokobi.wav?download=true" },
      { title: "Save The World", file: "https://huggingface.co/datasets/nekohacker591/music/resolve/main/mus/good%20remix%20rock%20sprit%20rock.wav?download=true" }
    ];

    const playerContainer = document.getElementById("player-container");

    function initializeAudioForPlayer(playerDiv) {
      if (playerDiv.audio) return; // Already initialized

      const audio = new Audio();
      audio.preload = "metadata"; // Load only metadata initially for lazy loading
      playerDiv.audio = audio; // Attach to player div

      const playBtn = playerDiv.querySelector('.play-btn');
      const progressFilled = playerDiv.querySelector('.progress-filled');
      const progressBar = playerDiv.querySelector('.progress');
      const volumeSlider = playerDiv.querySelector('.volume-slider');
      const muteBtn = playerDiv.querySelector('.mute-btn');
      const currentTimeDisplay = playerDiv.querySelector('.current-time');
      const durationDisplay = playerDiv.querySelector('.duration');
      const trackTitleElement = playerDiv.querySelector('.track-title');

      // Apply global/persisted volume and mute state
      audio.volume = globalPlayerState.isMuted ? 0 : globalPlayerState.lastVolume;
      volumeSlider.value = globalPlayerState.isMuted ? 0 : globalPlayerState.lastVolume; // Keep slider in sync
      muteBtn.textContent = globalPlayerState.isMuted ? 'ðŸ”Š' : 'ðŸ”‡';
      if(globalPlayerState.isMuted) volumeSlider.disabled = true;


      audio.addEventListener('loadedmetadata', () => {
        durationDisplay.textContent = formatTime(audio.duration);
        // If this track was meant to be played via URL param, play it now
        if (playerDiv.shouldAutoPlay) {
            playBtn.click();
            playerDiv.shouldAutoPlay = false; // Reset flag
        }
      });

      audio.addEventListener('timeupdate', () => {
        if (audio.duration) { // Ensure duration is available
          const percent = (audio.currentTime / audio.duration) * 100;
          progressFilled.style.width = percent + '%';
        }
        currentTimeDisplay.textContent = formatTime(audio.currentTime);
        if (!audio.paused) {
          document.title = `ðŸŽ§ ${trackTitleElement.textContent} - Nekohacker591`;
        }
      });

      audio.addEventListener('ended', () => {
        playBtn.textContent = 'â–¶';
        progressFilled.style.width = '0%';
        currentTimeDisplay.textContent = formatTime(0); // Reset current time display
        playerDiv.classList.remove('player-playing');
        if (globalPlayerState.currentPlayingPlayerDiv === playerDiv) {
            globalPlayerState.currentPlayingAudio = null;
            globalPlayerState.currentPlayingPlayerDiv = null;
            document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
        }

        // Autoplay next logic
        if (globalPlayerState.autoplayNext) {
            let currentPlayerIndex = -1;
            const allPlayers = Array.from(playerContainer.children).filter(p => p.style.display !== 'none'); // Consider only visible players
            for(let i=0; i<allPlayers.length; i++) {
                if(allPlayers[i] === playerDiv) {
                    currentPlayerIndex = i;
                    break;
                }
            }

            if (currentPlayerIndex !== -1 && currentPlayerIndex < allPlayers.length - 1) {
                const nextPlayerDiv = allPlayers[currentPlayerIndex + 1];
                if (nextPlayerDiv) {
                    const nextPlayBtn = nextPlayerDiv.querySelector('.play-btn');
                    if (nextPlayBtn) {
                        // Ensure next player is initialized if not already
                        if (!nextPlayerDiv.audio) {
                           initializeAudioForPlayer(nextPlayerDiv);
                           // Source needs to be set for initialization to complete
                           if (!nextPlayerDiv.audio.src) nextPlayerDiv.audio.src = nextPlayerDiv.dataset.src;
                        }
                        nextPlayBtn.click(); // Simulate click to play next
                    }
                }
            }
        }
      });

      audio.addEventListener('volumechange', () => { // Update mute button based on actual volume
          if (audio.volume === 0 || audio.muted) {
              muteBtn.textContent = 'ðŸ”Š'; // Show unmute icon
              volumeSlider.value = 0; // Reflect mute on slider
              volumeSlider.disabled = true;
              globalPlayerState.isMuted = true;
          } else {
              muteBtn.textContent = 'ðŸ”‡'; // Show mute icon
              volumeSlider.value = audio.volume;
              volumeSlider.disabled = false;
              globalPlayerState.isMuted = false;
              globalPlayerState.lastVolume = audio.volume;
          }
          localStorage.setItem('nekohacker_globalVolume', globalPlayerState.lastVolume);
          localStorage.setItem('nekohacker_isMuted', globalPlayerState.isMuted);
      });

      volumeSlider.addEventListener('input', () => {
        const newVolume = parseFloat(volumeSlider.value);
        audio.volume = newVolume;
        audio.muted = newVolume === 0; // Mute if volume is 0
        // The 'volumechange' event will handle UI updates and localStorage
      });

      muteBtn.addEventListener('click', () => {
          if (audio.muted || audio.volume === 0) { // Unmute
              audio.muted = false;
              audio.volume = globalPlayerState.lastVolume > 0 ? globalPlayerState.lastVolume : 0.1; // Restore last volume or a small default
              volumeSlider.value = audio.volume;
          } else { // Mute
              globalPlayerState.lastVolume = audio.volume; // Save current volume before muting
              audio.muted = true; // This will trigger volumechange if supported, or set volume to 0
              audio.volume = 0; // Explicitly set volume to 0 for visual consistency
          }
          // State saving is handled by 'volumechange' event
      });

      playBtn.addEventListener('click', () => {
        if (!audio.src) { // If src not set yet (e.g., initial click after IntersectionObserver)
            audio.src = playerDiv.dataset.src;
            //loadedmetadata will handle duration, play will be triggered below after src is set
        }

        if (audio.paused) {
          // Pause any other playing audio
          if (globalPlayerState.currentPlayingAudio && globalPlayerState.currentPlayingAudio !== audio) {
            globalPlayerState.currentPlayingAudio.pause();
            globalPlayerState.currentPlayingPlayerDiv.querySelector('.play-btn').textContent = 'â–¶';
            globalPlayerState.currentPlayingPlayerDiv.classList.remove('player-playing');
          }
          audio.play().then(() => {
            playBtn.textContent = 'â–®â–®';
            playerDiv.classList.add('player-playing');
            globalPlayerState.currentPlayingAudio = audio;
            globalPlayerState.currentPlayingPlayerDiv = playerDiv;
          }).catch(error => console.error("Error playing audio:", error));
        } else {
          audio.pause();
          playBtn.textContent = 'â–¶';
          playerDiv.classList.remove('player-playing');
          if (globalPlayerState.currentPlayingAudio === audio) {
              globalPlayerState.currentPlayingAudio = null;
              globalPlayerState.currentPlayingPlayerDiv = null;
          }
          document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
        }
      });

      progressBar.addEventListener('click', (e) => {
          if (!audio.duration) return; // Can't seek if duration isn't known
          const progressBarRect = progressBar.getBoundingClientRect();
          const clickPosition = (e.clientX - progressBarRect.left) / progressBarRect.width;
          audio.currentTime = clickPosition * audio.duration;
          if (audio.paused) { // If paused, update progress bar manually
            progressFilled.style.width = (clickPosition * 100) + '%';
            currentTimeDisplay.textContent = formatTime(audio.currentTime);
          }
      });

      // Set the src to start loading metadata (IntersectionObserver has already fired)
      // Do this last after all listeners are attached
      if (!audio.src) {
          audio.src = playerDiv.dataset.src;
      }
    }

    const observerOptions = {
      root: null, // viewport
      rootMargin: '0px',
      threshold: 0.1 // Trigger when 10% of the element is visible
    };

    const playerObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const playerDiv = entry.target;
          if (!playerDiv.audio) { // Initialize only if not already done
            initializeAudioForPlayer(playerDiv);
          }
          // No need to unobserve if we want to re-check (e.g. if src might change, but not in this case)
          // observer.unobserve(playerDiv); // Unobserve after initializing to save resources
        }
      });
    }, observerOptions);

    tracks.forEach((track, index) => {
      const playerDiv = document.createElement("div");
      playerDiv.className = "player";
      playerDiv.id = `player-${index}`;
      playerDiv.dataset.src = track.file; // Changed to data-src for clarity with lazy loading
      playerDiv.dataset.index = index; // Store index for autoplay next

      playerDiv.innerHTML = `
        <div class="track-title">${track.title}</div>
        <div class="controls">
          <button class="play-btn">â–¶</button>
          <div class="progress-container">
            <span class="current-time">0:00</span>
            <div class="progress"><div class="progress-filled"></div></div>
            <span class="duration">--:--</span>
          </div>
        </div>
        <div class="actions">
          <a class="download-link" href="${track.file}" download="${track.title}.wav">â¬‡ Download</a>
          <button class="share-btn">ðŸ”— Share</button>
          <span class="copied">Copied!</span>
        </div>
        <div class="volume-container">
          <button class="mute-btn">ðŸ”‡</button>
          <input type="range" class="volume-slider" min="0" max="1" step="0.01" value="${globalPlayerState.lastVolume}">
        </div>
      `;
      playerContainer.appendChild(playerDiv);

      // Share button logic (remains mostly the same, just ensure it's attached per player)
      const shareBtn = playerDiv.querySelector('.share-btn');
      const copiedMsg = playerDiv.querySelector('.copied');
      const baseUrl = window.location.origin + window.location.pathname;

      shareBtn.addEventListener('click', () => {
        const shareUrl = `${baseUrl}?id=${index}&share=true`;
        navigator.clipboard.writeText(shareUrl).then(() => {
          copiedMsg.classList.add('show');
          setTimeout(() => copiedMsg.classList.remove('show'), 1500);
        }).catch(err => console.error('Failed to copy share link: ', err));
      });
      
      playerObserver.observe(playerDiv); // Observe each player for lazy initialization
    });


    const searchInput = document.querySelector('.search-input');
    searchInput.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase();
      document.querySelectorAll('.player').forEach(player => {
        const title = player.querySelector('.track-title').textContent.toLowerCase();
        const isVisible = title.includes(query);
        player.style.display = isVisible ? 'block' : 'none';
        
        // If a playing track is hidden by search, pause it
        if (!isVisible && player.audio && !player.audio.paused) {
            player.audio.pause();
            player.querySelector('.play-btn').textContent = 'â–¶';
            player.classList.remove('player-playing');
            if (globalPlayerState.currentPlayingPlayerDiv === player) {
                globalPlayerState.currentPlayingAudio = null;
                globalPlayerState.currentPlayingPlayerDiv = null;
                document.title = 'ðŸŽ§ Nekohacker591 Portfolio';
            }
        }
      });

      const newUrl = new URL(window.location.href);
      if (query) {
        newUrl.searchParams.set('s', query.replace(/ /g, '+'));
      } else {
        newUrl.searchParams.delete('s');
      }
      window.history.replaceState({}, '', newUrl);
    });

    function setOgMetaTags(title, description, url) {
      document.title = title; // Also set the document title for consistency
      const metaTags = [
        { property: 'og:title', content: title },
        { property: 'og:description', content: description },
        { property: 'og:url', content: url },
        { property: 'og:type', content: 'music.song' }
      ];
      metaTags.forEach(tag => {
        let meta = document.querySelector(`meta[property="${tag.property}"]`);
        if (!meta) {
          meta = document.createElement('meta');
          meta.setAttribute('property', tag.property);
          document.head.appendChild(meta);
        }
        meta.setAttribute('content', tag.content);
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      const urlParams = new URLSearchParams(window.location.search);
      const id = urlParams.get('id');
      const shareMode = urlParams.get('share') === 'true';
      const searchQuery = urlParams.get('s');

      let pageTitle = 'ðŸŽ§ Nekohacker591 Portfolio';
      let pageDescription = 'Check out my music portfolio!';
      let pageUrl = window.location.origin + window.location.pathname;

      document.getElementById('autoplay-next').checked = globalPlayerState.autoplayNext; // Sync checkbox with loaded state

      if (shareMode && id !== null && tracks[id]) {
        const track = tracks[id];
        pageTitle = `ðŸŽ§ ${track.title} - Nekohacker591 Portfolio`;
        pageDescription = `Listen to "${track.title}" by Nekohacker591`;
        pageUrl = window.location.href; // Full share URL

        const playerToFocus = document.getElementById(`player-${id}`);
        if (playerToFocus) {
          document.querySelectorAll('.player').forEach(p => {
            p.style.display = (p === playerToFocus) ? 'block' : 'none';
          });
          document.querySelector('h1').style.display = 'none';
          document.querySelector('.search-bar').style.display = 'none';
          document.querySelector('.controls-header').style.display = 'none'; // Hide autoplay toggle in share mode
          
          const container = document.getElementById('player-container');
          container.style.maxWidth = 'none'; // Allow full width for single shared player
          container.style.width = '100%';

          // Ensure the shared track's audio is initialized and potentially autoplayed
          // The IntersectionObserver might not fire immediately if element is already visible
          // Or if the element is forced to be visible by JS before observer runs.
          if (!playerToFocus.audio) {
            initializeAudioForPlayer(playerToFocus);
          }
          // Small delay to ensure audio can be played after initialization
          playerToFocus.shouldAutoPlay = true; // Flag for autoplay after metadata loaded
          if (playerToFocus.audio && playerToFocus.audio.readyState >= HTMLMediaElement.HAVE_METADATA) {
             playerToFocus.querySelector('.play-btn').click(); // Autoplay if ready
             playerToFocus.shouldAutoPlay = false;
          }

          // Scroll to the player
          playerToFocus.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      } else if (searchQuery) {
        const cleanQuery = searchQuery.replace(/\+/g, ' ');
        searchInput.value = cleanQuery;
        // Trigger the input event to filter tracks
        const event = new Event('input', { bubbles: true, cancelable: true });
        searchInput.dispatchEvent(event);
      }

      setOgMetaTags(pageTitle, pageDescription, pageUrl);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Don't interfere if user is typing in the search bar
        if (e.target === searchInput) return;

        if (e.code === 'Space') {
            e.preventDefault(); // Prevent page scroll
            if (globalPlayerState.currentPlayingAudio) {
                const playBtn = globalPlayerState.currentPlayingPlayerDiv.querySelector('.play-btn');
                playBtn.click();
            } else {
                // Try to play the first visible, unplayed track
                const firstVisiblePlayer = Array.from(playerContainer.children).find(p => p.style.display !== 'none' && (!p.audio || p.audio.paused));
                if (firstVisiblePlayer) {
                    const playBtn = firstVisiblePlayer.querySelector('.play-btn');
                     if (!firstVisiblePlayer.audio) { // Ensure initialized
                        initializeAudioForPlayer(firstVisiblePlayer);
                        if (!firstVisiblePlayer.audio.src) firstVisiblePlayer.audio.src = firstVisiblePlayer.dataset.src;
                    }
                    playBtn.click();
                }
            }
        } else if (e.code === 'KeyM') { // M for Mute/Unmute
            if (globalPlayerState.currentPlayingAudio) {
                const muteBtn = globalPlayerState.currentPlayingPlayerDiv.querySelector('.mute-btn');
                muteBtn.click();
            }
        }
        // Add more shortcuts like ArrowLeft/Right for seek, ArrowUp/Down for volume for the currentPlayingAudio
        else if (globalPlayerState.currentPlayingAudio) {
            let handled = false;
            if (e.code === 'ArrowLeft') {
                globalPlayerState.currentPlayingAudio.currentTime = Math.max(0, globalPlayerState.currentPlayingAudio.currentTime - 5); // Seek back 5s
                handled = true;
            } else if (e.code === 'ArrowRight') {
                globalPlayerState.currentPlayingAudio.currentTime = Math.min(globalPlayerState.currentPlayingAudio.duration, globalPlayerState.currentPlayingAudio.currentTime + 5); // Seek forward 5s
                handled = true;
            } else if (e.code === 'ArrowUp') {
                globalPlayerState.currentPlayingAudio.volume = Math.min(1, globalPlayerState.currentPlayingAudio.volume + 0.1);
                handled = true;
            } else if (e.code === 'ArrowDown') {
                globalPlayerState.currentPlayingAudio.volume = Math.max(0, globalPlayerState.currentPlayingAudio.volume - 0.1);
                handled = true;
            }
            if (handled) e.preventDefault();
        }
    });

  </script>
</body>
</html>
